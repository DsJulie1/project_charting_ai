from dotenv import load_dotenv
load_dotenv()

import tiktoken
from langchain.chat_models import ChatOpenAI
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.prompts import PromptTemplate
from langchain.chains import LLMChain


def run_chartting(filename):
    #############|| SETTING ||#############
    # 모델 설정
    model_name='gpt-4-1106-preview'
    #######################################
    
    #############|| PROMPT ||##############
    prompt = """당신은 한의사 입니다. 한의사와 환자의 대화 내용이 주어지면 이를 바탕으로 주요 내용을 정리해야 합니다.
    내용에서 한의사가 발화한 부분은 “한의사 :” 으로 시작하고, 환자가 발화한 문장은 “환자 :” 로 시작합니다.
    정리된 결과에는 주소증, 발병일, 과거력, 가족력, 현병력 항목이 있어야 합니다.
    이 5개 항목에 기입해야 하는 내용은 아래와 같습니다.
    1. 주소증 : 환자가 어떤 부분이 불편해서 한의원에 방문했는지 기입합니다. 예) 왼쪽 발목 통증
    2. 발병일 : 주소증이 언제 시작되었는지 기입 합니다. 예를 들어, 3개월 전쯤부터 매우 피곤하였는데 결국 간경변증으로 진단하였다면 발병일은 3개월 전. 아무런 증상이 없는데 우연히 건강 검진에서 위암이 발견되었다면 건강검진을 한 날이 발병일.
    3. 과거력 : 환자가 과거에 앓았던 질환, 과거 수술 및 치료 이력, 과거 동일한 증상이 있었는지에 대해 기입 합니다. 다음 사항 또한 포함합니다. 수술력, 입원력, 암, 고혈압, 당뇨, 고지혈증, 결핵, 간염, 골관절염, 골다공증, 류머티즘, AIDS, 복약력, 임신력, 알레르기 등. 예) 과거에 동일한 질환으로 암 수술을 받음.
    4. 가족력 : 환자의 증상과 비슷한 증상을 보이는 가족이 있었다면 기입 합니다. 특히, 갑상선암과 같이 가족력이 높은 질환의 경우 기입 합니다.
    5. 현병력 : 현재 한의원에 방문하기 전까지 어떤 과정이 있었는지 기입합니다. 예) 3일 전 저녁 퇴근 중 발을 삐끗하면서 통증 시작. 집에서 아이스팩 하고 있었으나 부종과 통증이 점점 심해져서 정형외과 방문. X-ray 상 골절은 없다는 얘기 들고 진통제 처방 받음. 부종은 가라 앉았으나, 통증이 지속되어 방문함.

    어림 짐작으로 정리를 해서는 안되고, 각 항목에 해당하는 내용을 빠짐없이 구체적으로 정리해야 합니다.
    한의사와 환자의 대화 내용 바탕으로 정리할 수 없을 경우 '정보 없음'이라고 표현합니다. 이때, 해당 항목의 발췌 부분은 출력하지 않습니다.
    
    각 요소마다 출력할 때 순서대로 번호를 매깁니다. 예) 1. 주소증 : (1)발목 통증, (2)발목 부종
    각 요소와 가장 직접적으로 관련되어 있는 원본 내용을 발췌하여 출력 합니다. 이때, 발췌 부분만 보더라도 요소의 내용을 확인할 수 있어야 합니다.
    발췌 부분은 각 요소와 일대일 대응 되도록 각각 출력되어야 합니다. 예를 들어 현병력에 2개 요소가 출력되었다면 발췌 부분도 요소와 대응되도록 2개 출력되어야 합니다.
    발췌 부분은 각 요소와 순서를 맞추어 출력 합니다. 예를 들어, 첫번째 요소와 관련된 발췌 부분은 발췌 영역에서 첫번째로 출력 됩니다.
    각 발췌 부분 앞에는 해당 발췌 부분과 관련되어 있는 요소의 번호를 매깁니다. 예) - 발췌 : "(2)발목이 부었어요."
    말투는 "~했음"과 같이 명사로 끝나도록 합니다.
    
    대화 내용 예시는 아래와 같습니다.
    한의사 : 언제부터 아프셨어요?
    환자 : 3일 전쯤에 퇴근하면서 발목을 삐었거든요. 아프기 시작하더라고요.
    한의사 : 3일 동안 계속 참으신거예요?
    환자 : 집에서 아이스팩하고 그랬는데도 점점 부어오르고 아픈 게 더 심해지더라고요.
    한의사 : 그 정도면 골절이 되었을 수 도 있어요.
    환자 : 심해져서 결국 정형외과 다녀왔는데요. X-ray 찍으니까 골절은 없다고 하셔서 결국 진통제만 처방 받고 왔어요. 그래서 부은 건 좀 나아졌는데 계속 아파서요.
    한의사 : 이전에도 발목 삔 적 있으세요?
    환자 : 작년에 한 번 삔 적 있어요. 그때도 한의원에서 치료 받았어요.
    
    위의 대화 내용을 바탕으로 정리한 주요 내용 예시는 아래와 같습니다.
    1. 주소증 : (1)발목 접지름에 따른 통증
        - 발췌 : "(1)발목을 삐었거든요. 계속 아파서요."
    2. 발병일 : (1)3일 전
        - 발췌 : "(1)3일 전쯤에 퇴근하면서 발을 삐었거든요."
    3. 과거력 : (1)발목 접지름, (2)그에 따른 한의원 치료
        - 발췌 : "(1)작년에 한 번 삔 적 있어요. (2)그때도 한의원에서 치료 받았어요."
    4. 가족력 : 정보 없음
    5. 현병력 : (1)3일 전 퇴근 중 발을 삐끗하면서 통증 시작. (2)집에서 아이스팩 하고 있었으나 부종과 통증이 점점 심해져서 정형외과 방문. (3)X-ray 상 골절은 없다는 얘기 들고 진통제 처방 받음. (4)부종은 가라 앉았으나, 통증이 지속되어 방문함.
        - 발췌 : "(1)3일 전쯤에 퇴근하면서 발목을 삐었거든요.아프기 시작하더라고요.", "(2)집에서 아이스팩하고 그랬는데도 점점 부어오르고 아픈 게 더 심해지더라고요. 결국 정형외과 다녀왔는데요.", "(3)X-ray 찍으니까 골절은 없다고 하셔서 결국 진통제만 처방 받고 왔어요.", "(4)그래서 부은 건 좀 나아졌는데 계속 아파서요."
    
    위의 예시를 보면, 주소증의 발췌 부분만 보더라도 발목이 접질러서 통증을 호소하고 있다는 것을 바로 알 수 있습니다. 즉, 주소증으로 '발목 접지름에 따른 통증'이 잘 출력되었다는 것을 확인할 수 있습니다.
    위 예시의 주소증에는 발목 골절과 관련된 내용이 없습니다. 그 이유는 한의사가 골절이 되었을 수도 있다고 말했지만, 환자가 정형외과에 가서 진단 받았을 때 골절이 아니었다고 말했기 때문 입니다.
    또한, 현병력을 보면 발췌 부분과 현병력의 각 요소들이 순서에 맞게 일대응 대응되어 잘 출력되어 있습니다. 현병력 요소에 할당된 번호는 가장 관련된 발췌 부분에 할당된 번호와 같습니다.
    
    다음은 한의사와 환자의 대화 내용 입니다.
    {pages}
    이를 바탕으로 주요 내용을 정리해주세요.
    """
    #######################################
    # filename 객체의 이름을 파일 이름으로 사용
    file_name = filename.name  
    # 파일 불러오기
    with open(file_name, 'wb') as f:
        f.write(filename.getvalue())
    with open(file_name, 'r') as f:
        files_text = f.read()
    # 파일 내용 chunk
    text_chunks = get_text_chunks(files_text)
    # chartting 결과
    summary = chart(text_chunks, model_name, prompt)
    return summary


# 차팅결과 return
def chart(text_chunks, model_name, prompt):
    # Map 프롬프트 완성
    map_prompt = PromptTemplate.from_template(prompt)
    # Map에서 수행할 LLMChain 정의
    llm = ChatOpenAI(temperature=0, 
                    model_name=model_name)
    map_chain = LLMChain(llm=llm, prompt=map_prompt)
    summary = map_chain.run(text_chunks)
    return summary


# 토큰 개수 세는 함수(토큰을 기준으로 텍스트를 쪼개기 위한 함수)
def tiktoken_len(text):
    tokenizer = tiktoken.get_encoding("cl100k_base") # OPEAAI의 LLM을 사용하기 때문에 'cl100k_base' 토크나이저 사용
    tokens = tokenizer.encode(text)
    return len(tokens)


# 여러 개의 chunk 나누는 함수
def get_text_chunks(text):
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=900,
        chunk_overlap=100,
        length_function=tiktoken_len)
    chunks = text_splitter.create_documents([text])
    return chunks



